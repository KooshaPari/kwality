name: Kwality CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, develop ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  GO_VERSION: '1.23'
  RUST_VERSION: '1.75'

jobs:
  # Static analysis and security scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Semgrep security analysis
        uses: semgrep/semgrep-action@v1
        continue-on-error: true
        with:
          config: auto
          publishToken: ${{ secrets.SEMGREP_APP_TOKEN }}
          generateBaseline: true

  # Go backend testing and analysis
  go-test:
    name: Go Tests and Analysis
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: kwality_test
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download Go dependencies
        run: go mod download

      - name: Run Go linter
        uses: golangci/golangci-lint-action@v3
        continue-on-error: true
        with:
          version: latest
          args: --timeout=5m

      - name: Run Go tests
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_DATABASE: kwality_test
          DB_USER: postgres
          DB_PASSWORD: postgres
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          KWALITY_ENV: test
        run: |
          # Check if test files exist before running tests
          if find . -name '*_test.go' -type f | grep -q .; then
            echo "Found Go test files, running tests..."
            go test -v -race -coverprofile=coverage.out ./...
            go tool cover -html=coverage.out -o coverage.html
          else
            echo "No Go test files found, skipping tests but creating empty coverage file"
            echo "mode: set" > coverage.out
          fi

      - name: Upload Go test coverage
        uses: codecov/codecov-action@v3
        continue-on-error: true
        with:
          file: ./coverage.out
          flags: go
          name: go-coverage

      - name: Run integration tests
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_DATABASE: kwality_test
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          KWALITY_ENV: test
        run: |
          # Check if integration test files exist
          if find ./tests/integration -name '*_test.go' -type f 2>/dev/null | grep -q .; then
            echo "Found integration test files, running tests..."
            go test -v -tags=integration ./tests/integration/...
          else
            echo "No integration test files found, skipping integration tests"
          fi

  # Rust runtime validator testing
  rust-test:
    name: Rust Tests and Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          components: rustfmt, clippy

      - name: Cache Rust dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            engines/runtime-validator/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install Docker (for integration tests)
        run: |
          sudo apt-get update
          sudo apt-get install -y docker.io
          sudo systemctl start docker
          sudo usermod -aG docker $USER

      - name: Run Rust formatter check
        working-directory: engines/runtime-validator
        continue-on-error: true
        run: cargo fmt --all -- --check

      - name: Run Rust linter
        working-directory: engines/runtime-validator
        continue-on-error: true
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Run Rust tests
        working-directory: engines/runtime-validator
        continue-on-error: true
        run: |
          cargo test --verbose
          cargo test --verbose --release

      - name: Run Rust security audit
        working-directory: engines/runtime-validator
        continue-on-error: true
        run: |
          cargo install cargo-audit
          cargo audit

      - name: Check Rust dependencies
        working-directory: engines/runtime-validator
        continue-on-error: true
        run: |
          cargo install cargo-deny
          cargo deny check

  # Build and push Docker images
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [security-scan, go-test]
    if: always() && !cancelled() && (needs.security-scan.result == 'success' || needs.security-scan.result == 'failure') && (needs.go-test.result == 'success' || needs.go-test.result == 'failure')
    permissions:
      contents: read
      packages: write
    outputs:
      orchestrator-image: ${{ steps.meta-orchestrator.outputs.tags }}
      # runtime-validator-image: ${{ steps.meta-runtime.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build Go orchestrator image
      - name: Extract Go orchestrator metadata
        id: meta-orchestrator
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/orchestrator
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Go orchestrator image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-orchestrator.outputs.tags }}
          labels: ${{ steps.meta-orchestrator.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Temporarily disabled due to Rust compilation issues
      # - name: Extract Rust runtime validator metadata
      #   id: meta-runtime
      #   uses: docker/metadata-action@v5
      #   with:
      #     images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/runtime-validator
      #     tags: |
      #       type=ref,event=branch
      #       type=ref,event=pr
      #       type=semver,pattern={{version}}
      #       type=semver,pattern={{major}}.{{minor}}
      #       type=sha,prefix={{branch}}-

      # Temporarily disabled due to Rust compilation issues
      # - name: Build and push Rust runtime validator image
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: ./engines/runtime-validator
      #     file: ./engines/runtime-validator/Dockerfile
      #     platforms: linux/amd64,linux/arm64
      #     push: true
      #     tags: ${{ steps.meta-runtime.outputs.tags }}
      #     labels: ${{ steps.meta-runtime.outputs.labels }}
      #     cache-from: type=gha
      #     cache-to: type=gha,mode=max

  # End-to-end testing
  e2e-test:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: [build-images]
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: kwality_e2e
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Docker Compose with built images
        run: |
          sed -i "s|kwality/orchestrator:latest|${{ needs.build-images.outputs.orchestrator-image }}|g" docker-compose.kwality.yml
          # Runtime validator temporarily disabled due to compilation issues
          # sed -i "s|kwality/runtime-validator:latest|${{ needs.build-images.outputs.runtime-validator-image }}|g" docker-compose.kwality.yml

      - name: Start services
        run: |
          docker-compose -f docker-compose.kwality.yml up -d kwality-orchestrator postgres redis
          sleep 30

      - name: Wait for services to be ready
        run: |
          timeout 300 bash -c 'until curl -f http://localhost:8080/health; do sleep 5; done'

      - name: Run end-to-end tests
        run: |
          # Run API tests
          curl -f http://localhost:8080/health
          
          # Test validation endpoint with sample code
          response=$(curl -s -X POST http://localhost:8080/api/v1/validate/codebase \
            -H "Content-Type: application/json" \
            -d '{
              "name": "e2e-test",
              "source": {
                "type": "inline",
                "files": [
                  {
                    "path": "main.go",
                    "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, World!\")\n}"
                  }
                ]
              },
              "config": {
                "enabled_engines": ["static"],
                "timeout": "2m"
              }
            }')
          
          task_id=$(echo $response | jq -r '.task_id')
          echo "Validation task ID: $task_id"
          
          # Wait for validation to complete
          for i in {1..60}; do
            status=$(curl -s http://localhost:8080/api/v1/validate/$task_id | jq -r '.status')
            echo "Status: $status"
            if [[ "$status" == "completed" || "$status" == "failed" ]]; then
              break
            fi
            sleep 5
          done

      - name: Collect logs
        if: always()
        run: |
          docker-compose -f docker-compose.kwality.yml logs > e2e-logs.txt

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: e2e-logs
          path: e2e-logs.txt

      - name: Stop services
        if: always()
        run: |
          docker-compose -f docker-compose.kwality.yml down

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [e2e-test]
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://staging.kwality.dev
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."
          # Add staging deployment logic here
          # This could be Kubernetes, AWS ECS, or other deployment targets

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [e2e-test]
    if: startsWith(github.ref, 'refs/tags/v')
    environment:
      name: production
      url: https://kwality.dev
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."
          # Add production deployment logic here
          # This should include proper rollout strategies and monitoring

  # Performance benchmarking
  benchmark:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    needs: [build-images]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run Go benchmarks
        run: |
          # Check if benchmark files exist
          if find . -name '*_test.go' -type f -exec grep -l 'func Benchmark' {} \; | grep -q .; then
            echo "Found benchmark tests, running benchmarks..."
            go test -bench=. -benchmem ./... > go-benchmarks.txt
          else
            echo "No benchmark tests found, creating empty benchmark file"
            echo "No benchmarks found" > go-benchmarks.txt
          fi

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}

      - name: Run Rust benchmarks
        working-directory: engines/runtime-validator
        continue-on-error: true
        run: |
          cargo bench > rust-benchmarks.txt

      - name: Upload benchmark results
        uses: actions/upload-artifact@v3
        with:
          name: benchmarks
          path: |
            go-benchmarks.txt
            engines/runtime-validator/rust-benchmarks.txt

  # Notification on failure
  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [security-scan, go-test, build-images, e2e-test]
    if: failure()
    steps:
      - name: Notify Slack on failure
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#kwality-alerts'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow

  # Generate release notes
  release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [deploy-production]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        uses: release-drafter/release-drafter@v5
        with:
          config-name: release-drafter.yml
          publish: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}